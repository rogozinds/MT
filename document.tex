%!TeX encoding = ISO-8859-1
\documentclass[12pt,a4paper,english%,twoside,openright
]{tutthesis}
% Ensure the correct Pdf size (not needed in all environments)
\special{papersize=210mm,297mm}
%
% Define your basic information
%
\author{Dmitrii Rogozin}
\title{Testing in web/vaadin applications (draft)}      % primary title (for front page)
\thesistype{Master of Science thesis} % or Bachelor of Science, Laboratory Report... 
\examiner{Kari Systä} % without title Prof., Dr., MSc or such

% Special trick to use internal macros outside the cls file
% (e.g. \@author). Trick is reversed with \makeatother a bit later.
\makeatletter

% Define the pdf document properties.  Fill in your own keywords.
\hypersetup{   
  pdftitle={\@title},
  pdfauthor={\@author},
  pdfkeywords={Web-testing Automation testing Vaadin Selenium TestBench}
}
\usepackage[english]{babel}
%
% You can include special packages or define new commands here at the
% beginning. Options are given in brackets and package name is in
% braces:  \usepackage[opt]{pkg_name}
\DeclareGraphicsRule{*}{mps}{*}{}

\graphicspath{ {images/} }
\lstset{
  language=Java, % the language of the code
   basicstyle=\tiny                
}


% Preparatory content ends here



\pagenumbering{Roman}
\pagestyle{headings}
\begin{document}

% Create the title page.
% First the logo. Check its language.
\thispagestyle{empty}
%\vspace*{-.5cm}\noindent
\vspace*{-1cm}\noindent
\includegraphics[width=8cm]{tty_tut_logo}   % Bilingual logo

% Then lay out the author, title and type to the center of page.
\vspace{6.8cm}
\maketitle
\vspace{7cm} % modify if thesis title needs many lines

% Last some additional info to the bottom-right corner
\begin{flushright}  
  \begin{minipage}[c]{6.8cm}
    \begin{spacing}{1.0}
      %\textsf{Tarkastaja: Prof. \@examiner}\\
      %\textsf{Tarkastaja ja aihe hyv�ksytty}\\ 
      %\textsf{xxxxxxx tiedekuntaneuvoston}\\
      %\textsf{kokouksessa dd.mm.yyyy}\\
      \textsf{Examiner: Prof. \@examiner}\\
      \textsf{Examiner and topic approved by the}\\ 
      \textsf{Faculty Council of the Faculty of}\\
      \textsf{xxxx}\\
      \textsf{on 1st November 2015}\\
    \end{spacing}
  \end{minipage}
\end{flushright}

% Leave the backside of title page empty in twoside mode
\if@twoside
\clearpage
\fi
%
% Use Roman numbering i,ii,iii... for the first pages (abstract, TOC,
% termlist etc)
\pagenumbering{roman} 
\setcounter{page}{0} % Start numbering from zero because command 'chapter*' does page break


% Some fields in abstract are automated, namely those with \@ (author,
% title in the main language, thesis type, examiner).
\chapter*{Abstract}
\begin{spacing}{1.0}
         {\bf \textsf{\MakeUppercase{\@author}}}: \@title\\   % use \@titleB when thesis is in Finnish
         \textsf{Tampere University of Technology}\\
         \textsf{\@thesistype, xx pages, x Appendix pages} \\
         \textsf{xxxxxx 201x}\\
         \textsf{Master's Degree Programme in xxx Technology}\\
         \textsf{Major: }\\
         \textsf{Examiner: Prof. \@examiner}\\ % 
         \textsf{Keywords: }\\
\end{spacing}

The abstract is a concise 1-page description of the work: what was the
problem, what was done, and what are the results. Do not include
charts or tables in the abstract.(100-150 words)



\makeatother % Make the @ a special symbol again, as \@author and \@title are not neded after this
\chapter*{Preface}
This document template conforms to Guide to Writing a Thesis at
Tampere University of Technology (2014) and is based on the previous
template. The main purpose is to show how the theses are formatted
using LaTeX (or \LaTeX ~ to be extra fancy) .

The thesis text is written into file \texttt{d\_tyo.tex}, whereas
\texttt{tutthesis.cls} contains the formatting instructions. Both
files include lots of comments (start with \%) that should help in
using LaTeX. TUT specific formatting is done by additional settings on
top of the original \texttt{report.cls} class file. This example needs
few additional files: TUT logo, example figure, example code, as well
as example bibliography and its formatting (\texttt{.bst}) An example
makefile is provided for those preferring command line. You are
encouraged to comment your work and to keep the length of lines
moderate, e.g. <80 characters. In Emacs, you can use \texttt{Alt-Q} to
break long lines in a paragraph and \texttt{Tab} to indent commands
(e.g. inside figure and table environments). Moreover, tex files are
well suited for versioning systems, such as Subversion or Git.  
% \url{http://www.ctan.org/tex-archive/info/lshort/english/lshort.pdf}


Acknowledgements to those who contributed to the thesis are generally
presented in the preface. It is not appropriate to criticize anyone in
the preface, even though the preface will not affect your grade. The
preface must fit on one page. Add the date, after which you have not
made any revisions to the text, at the end of the preface.

~ 
% Tilde ~ makes an non-breakable spce in LaTeX. Here it is used to get
% two consecutive paragraph breaks

Tampere, 1.9.2015

~
Dmitrii Rogozin
%
% Add the table of contents, optionally also the lists of figures,
% tables and codes.
%

\renewcommand\contentsname{Table of Contents} % Set English name (otherwise bilingual babel might break this), 2014-09-01
%\renewcommand\contentsname{Sis�llys}         % Set Finnish name
\setcounter{tocdepth}{3}                      % How many header level are included
\tableofcontents                              % Create TOC

\renewcommand\listfigurename{List of Figures}  % Set English name (otherwise bilingual babel might break this)
%\renewcommand\listfigurename{Kuvaluettelo}    % Set Finnish name
\listoffigures                                 % Optional: create the list of figures
\markboth{}{}                                  % no headers

\renewcommand\listtablename{List of Tables}    % Set English name (otherwise bilingual babel might break this)
%\renewcommand\listtablename{Taulukkoluettelo} % Set Finnish name
\listoftables                                  % Optional: create the list of tables
\markboth{}{}                                  % no headers


%\renewcommand\lstlistlistingname{List of Programs}      % Set English name (otherwise bilingual babel might break this)
%%\renewcommand\lstlistlistingname{Ohjelmaluettelo} % SetFinnish name, remove this if using English
%\lstlistoflistings                                % Optional: create the list of program codes
%\markboth{}{}                                     % no headers


%
% Term and symbol exaplanations use a special list type
%

\chapter*{List of abbreviations and symbols}
%\chapter*{Lyhenteet ja merkinn�t}
\markboth{}{}                                % no headers

% You don't have to align these with whitespaces, but it makes the
% .tex file more readable
\begin{termlist}
\item [CC license] Creative Commons license
\item [LaTeX] 	   Typesetting system for scientific documentation
\item [SI system]  Syst\`eme international d'unit�s, International System of Units
\item [TUT] 	   Tampere University of Technology
\item [URL]        Uniform Resource Locator
\end{termlist} 

\begin{termlist}
\item [$a$] acceleration
\item [$F$] force
\item [$m$] mass
\end{termlist} 

The abbreviations and symbols used in the thesis are collected into a
list in alphabetical order. In addition, they must be explained upon
first usage in the text.


% Leave the backside of abbreviation list empty in twoside mode
\cleardoublepage

% The actual text begins here and page numbering changes to 1,2...
\newpage             % needed for page numbering
\pagenumbering{arabic}
\setcounter{page}{1} % Start numbering from zero because command
                     % 'chapter*' does page break
\renewcommand{\chaptername}{} % This disables the prefix 'Chapter' or
                              % 'Luku' in page headers (in 'twoside'
                              % mode)

\include{intro}
% \label{...} allows cross-referencing, e.g. 'as explained in
% Chapter~\ref{ch:intro}' Note that you may have to run the command
% 'latex' or 'pdflatex' twice to get cross-references correctly.  You
% can add labels e.g. to chapters, sections, figures, tables, and
% equations.

% You can write everything into single tex file. Alternatively, you
% can write each chapter into separate file and then include them her
	 
\chapter{Theoretical background}
\label{ch:thBackground} 
	\subsection{Terms and Definitions}
		21st century has become an era of web applications. Software systems developed
		as a web based applcation allowes the end user to access data via web browser
		from different parts of the world and also from different devices (laptop,
		phones,tablets) has become one of the main features of modern
		applications. 
		
		Static html web sites, with little amount of javascript, which were
		constituting the big part of the Web are passing away. Modern web
		applications are very interactive and dynamic, they are becoming
		more powerful, and the difference between desktop and web applications
		dissapears. Web technologies are developing so fast, that even such domain
		specific applications as IDE(Integrated Development Dnvironment), trading
		sytems or graphic editors can be accessed via web browser. The key concept
		that helps such complicated software to become web-based is a multi-tier
		arhcitecture - the concept where the parts of the system are divided into
		separate tiers. This allows to develop presentation tier, which is
		responsible for user interface generation and lightweight validation, to
		be separate from complicated business-logic which runs on the server
		side. As a consequence the presentation tier code may be executed on different
		platforms, including web browsers. 
		
		As an extend of the growth of web applications the developing and maintaining such complicated systems becomes more and more challenging.
		All applications have a lot of common features and problems which
		were already solved by developers beforehand. This is a good practise not to
		try to reenvent a whell, but take an already made solution. That is why many
		modern applications are based on one or several software frameworks. Indeed it
		is hard to imagine that some developers team will pick a programming
		language and start to develop everything from scratch, without using any
		framework or third-party library. Same implications are applyied for testing
		frameworks. The rapidly changing and highly competitive business environment,
		choosing a right toolset is one of the key factors of the sucess. 
		
		Nowdays some companies are still rely on manual testing or ignore this
		important part of software development at all. Such approach has several
		sorrowful consequences:
		
		1. The developers are affraid of changing already written
		code. Because they do not have a confidence that their changes will break something. They
			stop cleaning their production code because they fear the changes would
			do more harm than good. ``Their production code began to rot"
			\cite[p.123]{cleanCode} 
		2. The effort of finding errors and
			fixing them raises with the amount of code written. Because the developers can not localize the place where the error is
		actual happening.
		3. Developing new features become harder,if they are based on the part of the
		system which have errors.
		
		4. All in all this leads to increasing the cost of the whole system.
	 	
	 	To test easily the huge amount code an automated web testing is come into existence.
	 	 Web testing is a kind of software testing that accentuate on web which assists to slice down price,
	  lessen the exertion requisite to check web applications as well as web sites, amplify software value,
	   condense time-to-market and reusability of test cases are also be done. 
	   
		IEEE has defined software testing as the process of evaluating a software
		system to verify that it satisfies specified requirements [3 XU]. A set of
		requirments for the web application includes security, performance,
		presentation, etc. We will focus on several requirements for the web
		application which differ from desktop application. 
		
		One of the key requirements which makes testing web applications harder than
		testing desktop applicatiosn is support of different browsers and operating systems and also
		different devices. A lot of desktop applications are developed to support some
		particular operating system or different versions of the product are developed
		and maintained for different operating systems. Web applications on the
		contrary should support not only different operating systems, but also
		different browsers and devices. So, if developers team decides to support
		three operating systems (Windows, OSX, Android), three type of devices (phone,
		tablet, PC) and three browsers (Chrome, Firefox, Internet Explorer) the number
		of possible variations is already twenty seven. If you decide to support
		different version of browsers, which in some circumstances may vary a lot,
		the number of different configurations of tested machines will be close to
		one hudred. In this case manual testing is unexceptable, because it will lead
		to unwarranted expenses. 
		
		Another difference between web and desktop applications is
		navigation on the webpage and between pages, the unexpected state change via
		the browser Back button or direct URL entry in the browser. Also some
		resources or parts of the application can be not acccessable, due to
		connection problems or maintanance. Such unexpected behaviour may happen, and
		must be handled properly, not to crash the whole application.

		Web testing includes the different type of testing like:
			- functionality tests
			- compatibility tests
			- load tests
			- performance tests
			- integration tests
		All these types of tests are equivalent important and picking a tool which
		will help to write these tests is not an easy task. It is an advantage when
		the testing tool is using same principles and similiar programming language
		with other tools in the project. We think that using same programming language
		to write both tests and code is much easier for the developer. This idea is
		related to Test-Driven Development (TDD), when tests are written
		before production code.
		
		Test-Driven Development is a very popular methodology of software
			development. The main idea is to write tests first and then code. The main
			benefits of such approach are:
				1. The developer is sure that his code works as intendent, because all his
				code is tested.
				2. The errors are found at early stage of the development cycle, which
				reduces the cost of fixing problems.
			
			Three laws of TDD \cite[pp122]{Cleancode}[Book page 122]
				1. You may not write production code until you have written a failing unit
				test.
				2. You may not write more of a unit test than is sufficient to fail.
				3. You may not write more production code than is sufficient to pass the
				curently failing test.
			\iffalse	
					\subsection {Approaches in Web Testing}	
						\begin{textit}
							In this chapter I will explain
							what does testing actually meands. What types of testing exist: unit, integration, user-interface, regression,
						etc. What are the differences between these types of testing.
						
						Next I will prove why testing is so important in software development. Here I
						would like to mention some information about \textit{Quality control}. The
						idea is to show that testing increseases the speed of software development
						and also improves it's quality. So in terms of quality control testing will
						decrease the price and increase the value of the product for the end user.
						
						Also I want to mention other methodologies like \textit{Agile development},
						\textit{User experience design} and \textit{Test Driven Development}. And how
						testing can be used/integrated with these methodologies/processes.
						\end{textit}
			\fi


\include{webtesting}

\iffalse  
	\subsection{User interface testing}	
		Some information why user interface testing is important and also why
		automated user interface testing is even more important. So we are narrowing
		the scope of the problem, not to talk about all types of testing.

		
		Afterwards I will introduce Vaadin, what's the main idea behind the framework.
		Also here I will introduce Testbench tool and Selenium- the basis of
		testbench. Thought the testbench is already exists, I would like here to tell
		what are the reasons of having Testbench, why it is needed why it was started.
		What are pros and cons. Here I'm not talking in detail about Testbench, I'm
		just introducing it.
\fi

\chapter{Development of Testbench}
\include{testbenchdevelop}
\label{ch:testbenchdevelop}
   	
\include {testbenchuse}   	
  
      
 \subsection {Comparing Testbench with other tools}
    Here I will compare testbench to some other testing tools for example
    Selenium, what are benefits of using Testbench. The main idea is to focus
    that Vaadin is a client-server framework, so all Vaadin components have
    client and server side code, and it's important to test both. I want to show
    what problems may happen if using only Selenium and test only client side
    code, so that server side isn't tested. 
    
    Also I would like to compare how complicated is to right Selenium and
    Testbench tests. How much code is needed to test button click for example,
    or sending text to a textField.
    
    Compare speed of running tests. In Vaadin we run tests every night, and
    sometimes it takes too much time, so I would like to mention ,what are the
    problems/challenges in having a lot of tests.

\iffalse      
 \subsection {Vaadin integration}
    Testbench using some features of Vaadin framework, for example searching
    elements by vaadin selectors. So I want to describe how integration with
    Vaadin is done. What are the challenges. For example what would happen when
    using different versions of Testbench with different versions of Vaadin.
\fi    




 \section {Discussion and Conclussion}
 	Middle of April/ End of April
 	\subsection {Summary}
 	  What has been done. What were the challenges how they were solved.
 	\subsection {Advantages and disadvantages}
 	\subsection {Future work}
 	
 	
	\begin{thebibliography}{7}
	
		\bibitem{Xu1}
			Lei Xu, Baowen Xu,
			"A framework for Web applications testing.",
			Proceedings of the International Conference on Cyberworlds.2004, pp.300-305
		\bibitem{Zhongen2}
		Qian Zhongsheng,Miao HuaiKou,Zeng Hongwei.
		 A practicalweb testing model for web application testing[C] .
		 Third International IEEE Conference on Signal-Image Technologies and
		 In-ternet-Based System. 2007, pp.434-441.
		 
		\bibitem{Cleancode}
		Robert C. Martin,
		Clean Code: A Handbook of Agile Software Craftsmanship,
		Prentice Hall PTR, Upper Saddle River, NJ, 2008
		
		\bibitem{testGen3}
		Seung Hak Kuk, Hyeon Soo Kim,			
		"Automatic Generation of Testing Environments for Web Applications.",
		Computer Science and Software Engineering, 2008 International Conference on
		(Volume:2 ). 12-14 Dec. 2008, :694 - 697
		
		\bibitem {selenium4}
		M. Leotta, D. Clerissi, F. Ricca, C. Spadaro,
		"Repairing Selenium Test Cases:An Industrial Case Study about Web Page
		 Element Localization," in the Proc. of Sixth International Conference on Software Testing, Verification and Validation, pp. 487-488, 2013. 
		\bibitem{pageObject5}
		M. Leotta, D. Clerissi, F. Ricca, and C. Spadaro. Improving test suites
		maintainability with the page object pattern: an industrial case study.
		In Proceedings of the 6th International Conference on Software Testing, Verification and Validation Workshops,
		ICSTW 2013, pages 108-113. IEEE, 2013. 
		\bibitem{CaptureReplay7}
		
		
		\bibitem{performance6}
		Angmo R. , Sharma M.	
		Performance evaluation of web based automation testing tools.,
		Confluence The Next Generation Information Technology Summit (Confluence),
		2014 5th International Conference. 25-26 Sept. 2014, pp. 731 - 735
		\bibitem {bookVaaidn} 
		 Author name.
		\bibitem {tiobeIndex}
		http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html
		\bibitem{vaadinTestbenchSite}
		https://vaadin.com/add-ons/testbench
		\bibitem {maven}
		http://maven.apache.org
		\bibitem {ant}
		http://ant.apache.org
		\bibitem {junit}
		http://junit.org/
		\bibitem {yodatime}
		http://www.joda.org/joda-time/
		\bibitem {guava}
		https://github.com/google/guava
		\bibitem {akka}
		http://akka.io/
		\bibitem {akkaUseCases}
		http://doc.akka.io/docs/akka/snapshot/intro/use-cases.html
		\bibitem {vaadinAkka}
		https://github.com/rogozinds/VaadinWithAkka
	\end{thebibliography}
  \section {Appendix}
\end{document}

//TODO
{Other frameworks ideas} part give a name to all aprroaches or at least a link
add picture of the framework tool
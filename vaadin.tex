	
	   As we see in the above example Vaadin gives an opportunity to use already
    made Java solutions with minimum/no overhead. The server-side code is pure
    Java and can use a third-party framework or third-party library to ease the
    development process. For testing server-side code we can use JUnit framework
    which already has become a standart in the Java world.
    
    The difficulties come when testing client side. The client side code is
    compiled to Javascript and executed in a Web-browser, that is why we can not
    use a Junit framework to test it. The challenge is that we need to have a
    framework which can operate on a html page raising javascript events and
    simulating user interaction, but also sends requests related to these
    interactions to the server side. In the following chapter we will
    present several ideas about such testing framework.  
	
	\section {Intergrating Vaadin with other frameworks}
	  As mentioned in (link to scratch) one of the key factors for a successful
	  development process is to pick a right toolset. Integrating server-side
	  code and other Java frameworks or libraries is easy and needs the minimum
	  amount of ``glue code''. In the following section we will show how to
	  integrate Vaadin and Akka.
	   
	  \subsection {Integrating witk Akka}
	  Akka is a Java/Scala framework for writting concurrent, fault-tolerant and
	  scalable applications. The Akka framework was adopted by many organizations
	  in a big range of industries all from investment and merchant banking, retail and social media,
	   simulation, gaming and betting, automobile and traffic systems, health care,
	   data analytics and much more\cite {akkakUseCases}. Using akka with Vaadin
	   gives an opportunity to develop concurrent, high responsive Web
	   applications. Using Akka provides an
	   opportunity of developing multithreaded easily-scalable backend, when
	   changes are pushed to the client-side asynchronously(not-blocking UI). 
	   We created a sample project which solves the classical Producer-Consumer
	   problem. In this particular example Prouducer is a pool of subscriptions and
	   Consumer is a service provide, which service should be granted, according to
	   business logic.
	   
	   The main idea is the following:
		 We have one service provider, which approves requests, a request in our case
		 is a subscription for some abstract service.
		 We request several subscriptions from UI, each subscription is a thread safe task. The provider can work simulteneosly
		 only with fixed amount of tasks, if the limis is exceeded the provider sends a message to a subscription,
		 that the subscription request is put into the queue and will be initiated a
		 timeout. The information about approved subscriptions is send to the UI
		 asynchronously. The idea in this example is that when the Provider is
		 overloaded and has no resources to process the request it sends the message
		 to the client, that its request was recieved and will be processed later. The
		 client recieves this information instead of just handling. So the goal to get
		 a higly responsive application is arhcieved. The complete example can be
		 downloaded here \cite{vaadinAkka}
	
  
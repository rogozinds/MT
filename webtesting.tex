	\chapter{Web testing}
	\label{ch:webtesting}

		There are several approaches for web testing, the choice among them depends on
		different factors such as lifecycle of the project, technologies used, the
		budget, the professional level of developers. Two main ideas are Capture and
		Replay tests (C\&R) and programmable tests.
		
		\section{C\&R}
		\label{sec:captureReplay}
			C\&R web testing is based on capture/replay automated
			tools. \cite{CaptureReplay7} The software tester works with the web
			application modeling user behaviour, the capture/replay tool records the
			whole session and generates the script, which can be executed later,
			repeating same actions without humans participation. These scripts are then
			might be edited for comparing expected and actual resutls of the user
			actions.Script editing might be useful to adjust failed sciprts accordingly
			to the changes of the web page. Thought if the web page was changed
			significantly, editing test script might be more expensive than recording the
			test from scratch. 
			
			We must admit that C\&R approach is very popular, there are plenty of
			frameworks both for desktop and web applications such as TPTP GUI Recorder, SWTBot, QF-Test,
			Selenium IDE.
			The main advantage of this method of testing, is that the tester doesn't
			require to have experience in coding and building test cases with such tools is a simple task. 
			
			On the contrary, maintaing tests is harder and more expensive.
			The main problem is that editing generated scripts is harder than editing
			scripts written by a software debeloper. The test cases are strongly coupled
			with web pages, contain hard-coded values. These factors leads to the
			problem, that very often the tester have to record a new test, instead of
			changing the existing ones. When using C\&R tools the tester/developer can
			not use loose-coupling and decomposition, and other design tehniques to make
			easy read and maintained tests. It is hard to use parts of already made test
			cases when creating new ones if they have common parts. Basically the main
			approach is to spend a lot of time recording tests all over again and again.
			Programmable tests can help to solve these problems.
			
		\section{Programmable tests} 
		\label{sec:programTests}
			Programmable tests are created by a tester manually. This method requires the
			person to have programming skills and takes more time, but programmable tests
			are more flexible and allow the developer to use bigger set of tools. The
			developer may use conditional statements (to change execution of the test),
			loops (to repeat same actions), exception handling, data structures (arrays,
			sets, trees, graphs), logging, etc. Programmable tests are more flexible and
			powerful than C\&R tehnique and provides the ability to create parameterized
			tests - tests which can be executed multiple times with different arguments.
			To show that programmable tests are more powerful than C\&R we provide an
			example.
			
			Suppose we have a web framework with set of UI element classes and want to
			test that changing elements value triggers a value change listener event.
			First we create a web page where we add elements we
			want to test (textfield, combobox, radio button, etc.) and an assertion input
			element. The assertion element will include a string, which will be
			compared with expected value.
			UI elements are added to a hash map as keys.
			Strings which will be set to the assertion element are added as values to the same map. Then we
			iterate through all values in the map and add elements to the webpage and set
			their ids. We also add value change listeners, which will set
			the value of the extra element according to the event triggered. Finally we
			get a web page with set of elements. When setting value of an element with
			some id will set the assertion element to have the same id as value. For
			example if an element with an id ``textfield'' changed its value the
			assertion element will have string ``textfield'' as value.
					
\begin{lstlisting}
public class TestWebPageClass {
	static final String ASSERT_ELEM_ID="assertElementId";
	 static Map<AbstractElement,String> map = new HashMap();
	 static  {
  	   map.put(new TextField(),"textField");
  	   map.put(new ComboBox(), "combobox");
	}

	TextField assertionElement=new TextField();
	public void createTestWebPage () {
	    Iterator it = classToAssertValue.entrySet().iterator();
	    while (it.hasNext()) {
	    it.getKey().setId(it.getValue());
	    addElementToWebPage(it.getKey());
	    it.getKey().setValueChangeListener(event-> {
	      assertionElement.setValue(it.getValue());
	      });
	  	}
		addAssertElement();
	}  
	
	public static <AbstractElement,String> getMap() {
		return map;
	}
}
\end{lstlisting}
      
      In our test we iterate through all elements in the map and find the
      element on the test web page by id. Then set a value to this element,
      at this point the value change listener of the element should be triggered and set the value
      of the assertion element. In the last step we compare the value in the
      assertion element with a value in the map.
			
\begin{lstlisting}
public class ValueChangeListenerTestClass {
	<AbstractElement,String> map=TestWebPageClass.getMap();
	String assertElementId=TestWebPageClass.ASSERT_ELEM_ID;
	UIElement assertElement=findElementById(assertElementId);
       
    @Test
    public void testValueChangeListener() {
    	openWebPage();
        Iterator it = map.entrySet().iterator();
          
        while (it.hasNext()) {
        	Map.Entry pair = (Map.Entry)it.next();
        	UIElement elem=findElementById(map.getValue());
        	elem.setValue(``foo'');
        	String assertMessage=``Element with id=''+pair.getValue()
        	+ ``has wrong value'';
        
        	Assert.assertEquals(assertMessage,assertElement.getValue(),
        	pair.getValue);
        }
    }
}
\end{lstlisting}
  
      As mentioned before, the biggest advantage of programmable tests against
      C\&R is scalability. When using programmable tests, testing new elements
      requires just adding these elements to the map. But when using C\&R a
      tester should record same actions for each new element. If later for
      example we decide to have a test that checks that getValue() mehtod
      returns the same value as it was set with setValue method we can create
      a new test method which will use the same map of elements. 

\begin{lstlisting}
	//test getValue() and setValue()
	@Test
	public void testSetValue() {
    	openWebPage();
    	private String testValue="foo";
    	Iterator it = map.entrySet().iterator();
    	while (it.hasNext()) {
    		Map.Entry pair = (Map.Entry)it.next();
			UIElement elem=findElementById(map.getValue());
            elem.setValue(``foo'');  
            Assert.assertEquals(elem.getValue(),testValue);        
        }
    }
\end{lstlisting}

      As a result we can see that thought writing programmable tests with
      compare to C\&R is harder and requires more experience and skills, they
      provide more flexibility and scalability. The empirical study
       of developing tests for four different frameworks shows that the development of programmable tests is more time
      consuming (between 32\% and 112\%), but test maintanance requires less
      time (with a saving of 16\% and 51\%). As a result ``In general, programmable test cases are more
expensive to write but easier to evolve than C\&R ones, with an advantage after
2 releases (in the median case)''.\cite{CaptureReplay7}

   \section {Other frameworks ideas}
   		Paper \cite{Xu1} and \cite{Zhongen2} describe of the capture-replay
   		tehnique.
   		The testing monitor agent chooses the user scenario (which is written by the tester/developer),
   		 then testing agent executes the scenario and outputs the testing
   		 resutls to the monitor agent. Then the monitor compares the test output
   		 with the expected result and prints the final report. The example of the
   		 test case in paper \cite{Zhongen2}
   		 \lstset{language=XML}
   		 \begin{lstlisting}
			 <request url = "http://mytestwebsite/login.asp"> 
			 	<parameter name = "name" value = "computer"/> 
			 	<parameter name = "password" value = "hello"/> 
			</request> 
			<response> 
			 	<match op = "contains" regexp=false select = 
			 	"/html/body" value = "Login Error!"/> 
			</response> 
   		\end{lstlisting}	
		This approach has one major disadvantage, such test framework can not test
		the application UI, it tests only server side logic, while client
		side stays untested. Another minor issue is that developer wants to write
		code and tests using same language, the reason is that code and tests are
		written in parallel, so testing framework should be very close to the
		developing framework and/or programming language.
		
		The paper \cite{testGen3} describes an improved tool for web application testing. 
			``The test driver for testing the client-side pages has the structure as
			shown in Fig.1. (1)  is the parameter initialization part. This part reads the test data and 
		 initializes parameters shown in the  user interface form. (2) is the test 
		 execution part that executes the  user interface form on the target 
		 page. In the part (2), the control  script written in the script 
		 languages like Javascript simulates event user actions in the web browser. (3) is the inner frame 
		 that contains the target page.'''
		  This tool allows to test client-side code, because the test driver
		  contains the target page and script to simulate user actions in the
		  web browser. 
		  				Figure 1
		Both approaches 1 and 2 have one major disadvantage:
			Client side testing is not complete. Thought approach includes client side
			page, it does not provide any tool for testing appearence of the webpage. The
			client side page may have bugs in css or html, for example if all html
			elements had css rule display:none, they would not be shown for user in the
			web browser. Thought all user actions could be still emulated by javascript.
	\section {Challenges}
		Papers \cite{Xu1} \cite{Zhongen2} and \cite{testGen3} include very simple examples
		(login page). Real-life example may have dozens/hundreds of html elements on the webpage. This is a typical
		situations in web applications, for example gmail, ebay. Navigating in big and
		branched DOM structure is not trivial. 
		There are several Methods for Locating Web page Elements:
		\begin{itemize}
		  \item By id -locates the web page elements using their id values.
		  \item By name -locates the web page elements using their name.
		  \item By tag - locates the web page elements using their tag.
		  \item By class - locates the web page elements using their class.
		  \item By XPath - selects a web page element by navigating the HTML tree.
		\end{itemize}

		XPath is the language used for locating nodes in an XML document. As HTML can
		be an implementation of XML (XHTML), users can use this language to target
		elements in the web applications.	

	\section {Selenium}
      Selenium is a set of different software tools each with a different approach
       to supporting test automation. The entire suite of tools allows many
       options for locating UI elements and comparing expected test results
       against actual application behavior \cite{seleniumSite}.
       Selenium provides implementation both of C\&R \ref{sec:captureReplay}
       \ref{sec:programTests} and programmable tests models.  
       
       \textbf{Selenium IDE} - is a development environment with graphical interace for building test scripts.
		Selenium IDE has a recording feature,  which records user actions as they are
		performed and then exports them as a reusable script in one of many programming languages that can be later executed.
       
       \textbf{Selenium  WebDriver} makes direct calls to the browser using browser's native support for automation. WebDriver represents a web browser, hiding specific browser details, behind the interface see
       figure~\ref{fig:webdriver}. Having a unified interface provides
       multi-browser support and allows same tests to be executed in different
       envirements.
       
	    \begin{figure}
		\label{fig:webdriver}
		\includegraphics[width=0.75\textwidth, center]{webdriver_structure}
		\caption{WebDriver structure}
		\end{figure}
       
       \textbf{Selenium Grid} allows to execute tests on different machines.
       Selenium Grid is useful for projects with large amount of tests or test
       suites that must be run in multiple environments.
       
		Grid allows to add several physical machines to a test cluster. Grid uses the
		term ``hub'' for a central point where all tests are loaded. Hub is responsible
		for distributing the tests across nodes. ``Node'' is  a remote machine with
		specific configuration which is attached to the hub see
		figure~\ref{fig:selnium_grid}. Nodes are totally separated from each other and
		may have different operating systems and browsers. Hub ``decides''
		for each test suite on which node it should be executed based on test's configuration.
		By default every node	starts eleven browsers : five Firefox, five Chrome and
		one Internet Explorer.
		
		\begin{figure}
		\label{fig:webdriver}
		\includegraphics[width=0.75\textwidth, center]{selenium_grid}
		\caption{Selenium Grid structure}
		\end{figure}
		
		Selenium Grid is published as a separate jar file, so to setup a test hub you
		only need to have JRE(Java Runtime Envirenment) installed. To start hub run
		selenium-server with hub parameter see \ref{lst:starthub} and to start a new
		node specify a webdriver parameter and the URL of the hub running \ref{lst:startnode}.
		
		\begin{lstlisting} [ label={lst:starthub},language=bash, caption=Start hub ]
		 java -jar	selenium-server-standalone-2.30.0.jar -role hub
		\end{lstlisting}

		\begin{lstlisting} [caption=Start node, label={lst:startnode},language=bash]
		java -jar selenium-server-standalone-2.30.0.jar -role webdriver
		-hub http://http://192.168.1.1:4444/grid/register -port 5566
		\end{lstlisting}
		

	To create a test suite for the Grid configuration created above see an
	example \ref{lst:starthub2}. Here is a explanation of basic :
	\begin{itemize}
	  \item Specify a url of tested web page line 6.
	  \item Specify a url of a node where test will run line 7.
	  \item Specify settings of the test, for example a browser line 8.
	  \item Create an instance of remote webDriver line 9.
	  \item Open a tested web page line 14.
	  \item Compare actual value on a webpage with expected value line 15.
	  \item Close web page line 20.
	\end{itemize}
	
	
	The algorithm for creating a test suite is straight forward.
	\lstset{style=a1listing}
	\begin{lstlisting} [caption=Selenium test example,label={lst:starthub2},language=java]
public 	class TestExample throws MalformedURLException {
 	WebDriver driver;
 	 String UIUrl,nodeURL;
 	 @BeforeTest public void setUp() {
 	 	UIUrl="http://app.example.com/hellopage"; 
		nodeURL="http://192.168.1.2:5566/wd/hub";
		DesiredCapabilities capability=DesiredCapabilities.firefox();
		driver=new RemoteWebDriver(new URL(nodeURL),capability);
	}
		
	@Test
	public void test1() {
		driver.get(UIUrl);
		Assert.assertEquals("Welcome",driver.getTitle());
	}
	
	@AfterTest
	public void afterTest() {
		driver.quit();
	}
}
	\end{lstlisting}


	Selenium Grid allows to run tests in parallel by running different tests
       at the same time on different remote machines. Distributing tests across
       multiple physical or virtual machines gives an opportunity to execute
       tests on diffrent operating systems and browsers. 
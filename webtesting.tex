	\chapter{Web testing}
	\label{ch:Webtesting}

		There are several approaches for Web testing, the choice among them depends on
		different factors such as lifecycle of the project, technologies used, the
		budget, the professional level of developers. Two main ideas are Capture and
		Replay tests (C\&R) and programmable tests.
		
		\section{Capture and Replay}
		\label{sec:captureReplay}
			C\&R Web testing is based on capture/replay automated
			tools\cite{CaptureReplay7}.  The software tester works with the Web
			application modeling user behaviour, the capture/replay tool records the
			whole session and generates the script, which can be executed later,
			repeating same actions without humans participation. The main idea of C\&R
			testing tools is to record a sequence of browsing steps, that can be
			automatically replayed later and save them in human readable format. Human
			readable format is an important feature, because script editing might
			 be useful to adjust failed scripts accordingly	to the changes of the Web page. Thought if the Web page was changed
			significantly, editing test script might be more expensive than recording a
			new test\cite{AnupamCaptureReplay}. 
			
			C\&R tools are usually Web browser plugins or Java applets, because they
			need to control a Web browser to navigate to a Web page. User actions are
			usually saved as a sequence of steps in HTML or XML. An example of C\&R
			test can be such HTML document, which is later used to generate a
			Javascript no reproduce user actions. The example test {lst:capturereplay}
			opens a URL type two numbers to fields with ``number1'' and ``number2'', then
			clicks and ``add'' button and verify the result.

\lstset{style=console}
\begin{lstlisting} [caption=Generated C\&R test  example,label={lst:capturereplay}]
<tr> <td>open</td>
  <td>/tutorials/selenium/selenium_record_replay.htm</td>
  <td></td>
</tr>
<tr>
  <td>type</td>
  <td>id=number1</td>
  <td>123</td>
</tr>
<tr>
  <td>type</td>
  <td>id=number2</td>
  <td>123</td>
</tr>
<tr>
  <td>click</td>
  <td>id=add</td>
  <td></td>
</tr>
<tr>
  <td>verifyValue</td>
  <td>id=total</td>
  <td>246</td>
</tr>
\end{lstlisting}
      
We must admit that C\&R approach is very popular, there are plenty of
frameworks both for desktop and Web applications such as TPTP GUI Recorder, SWTBot, QF-Test,
Selenium IDE.	The main advantage of this method of testing, is that the tester does not
require to have experience in coding and building test cases with such tools is a simple task. 
			
			On the contrary, maintaining tests is harder and more expensive.
			The main problem is that editing generated scripts is harder than editing
			scripts written by a software developer. The test cases are strongly coupled
			with Web pages and contain hard-coded values. These factors lead to the
			problem, that very often the tester have to record a new test, instead of
			changing the existing ones. When using C\&R tools the tester can
			not use loose-coupling and decomposition, and other design techniques to make
			easy readable and maintainable tests. It is also hard to use parts of already
			made test cases when creating new ones. Programmable tests can help to solve these problems.
			
		\section{Programmable tests} 
		\label{sec:programTests}
			Programmable tests are created by a tester manually. This method requires the
			person to have programming skills and takes more time, but programmable tests
			are more flexible and allow the developer to use bigger set of tools. The
			developer may use conditional statements to change execution of the test,
			loops to repeat same actions, exception handling, data structures like
			arrays, sets, trees, graphs, logging and etc. Programmable tests are more
			flexible and powerful than C\&R technique and provides the ability to create
			parameterized tests - tests which can be executed multiple times with different arguments. 

      Thought writing programmable tests is harder in
      compare with C\&R and requires more experience and skills, programmable tests
      provide more flexibility and scalability. The empirical study
       of developing tests for four different frameworks shows that the development of programmable tests is more time
      consuming (between 32\% and 112\%), but test maintenance requires less
      time (with a saving of 16\% and 51\%). As a result ``In general, programmable test cases are more
      expensive to write but easier to evolve than C\&R ones, with an advantage
      after two releases (in the median case)''.\cite{CaptureReplay7}

 \section{Capture and Replay vs Programmable tests}
  		To show that programmable tests are more powerful than C\&R we provide an
			artificial example of testing Vaadin framework.		
			Vaadin has a set of UI element classes and we want to	test that changing elements value triggers a value change listener event.
			First we create a Web page where we add elements we
			want to test such as text field, combo box, radio button and an	assertion
			input element see TestWebPageClass \ref{lst:vaadintest}.
       UI elements are added to a hash map
			as keys. Strings which will be set to the assertion element are added as
			values to the same map line 5.
			An assertion element we include a string line 9, which will be  compared with
      expected value.  Then we iterate through all values in the map, set their
      ids line 13 and add elements to the Web page line. We also add value
      change listeners line 15, which will set the value of the assertion
      element according to the event triggered. Finally we get a Web page with set of elements. 
      Setting value of an element will set the assertion element to have the id
      of this element as value. For example if an element with an id
      ``textfield'' has changed its value, the assertion element will have
      string ``textfield'' as value.
					
\lstset{style=a1listing}
\begin{lstlisting} [caption=Test Web Page class,label={lst:vaadintest}]
public class TestWebPageClass {
  static final String ASSERT_ELEM_ID="assertElementId";
  static Map<AbstractElement,String> map = new HashMap();
  static  {
    	   map.put(new TextField(),"textField");
    	   map.put(new ComboBox(), "combobox");
  }
  
  TextField assertionElement=new TextField();
  public void createTestWebPage () {
    Iterator it = classToAssertValue.entrySet().iterator();
  	while (it.hasNext()) {
  	 it.getKey().setId(it.getValue());
  	 addElementToWebPage(it.getKey());
  	 it.getKey().setValueChangeListener(event-> {
  	   assertionElement.setValue(it.getValue());
  	 });
  	}
  	
  	addAssertElement();
  }  
  	
  	public static <AbstractElement,String> getMap() {
  		return map;
  	}
}
\end{lstlisting}
      
Afterwards we create a test we iterate through all elements in the map and
find the element on the test Web page by id \ref{lst:vaadintest2}. Then set a
value to this element, a value change listener of the element should be triggered and set the value
of the assertion element. In the last step we compare the value in the
assertion element with a value in the map.

\lstset{style=a1listing}			
\begin{lstlisting} [caption=Test class,label={lst:vaadintest2}]
public class ValueChangeListenerTestClass {
	<AbstractElement,String> map=TestWebPageClass.getMap();
	String assertElementId=TestWebPageClass.ASSERT_ELEM_ID;
	UIElement assertElement=findElementById(assertElementId);
       
  @Test
  public void testValueChangeListener() {
    openWebPage();
    Iterator it = map.entrySet().iterator();
          
    while (it.hasNext()) {
      Map.Entry pair = (Map.Entry)it.next();
      UIElement elem=findElementById(map.getValue());
      elem.setValue(``foo'');
      String assertMessage=``Element with id=''+pair.getValue()
        	+ ``has wrong value'';
        
      Assert.assertEquals(assertMessage,assertElement.getValue(),
        	pair.getValue);
      }
    }
}
\end{lstlisting}
  
      As mentioned before, the biggest advantage of programmable tests against
      C\&R is scalability. When using C\&R a
      tester should record same actions for each new element, while with 
      programmable tests, testing new elements requires just adding these elements to the map.
      
      If later we decide to have a test that checks that ``getValue()'' method
      returns the same value as it was set with ``setValue()'' method we can create
      a new test method which will use the same map of elements see
      \ref{lst:vaadintestextend}.

\lstset{style=a1listing}      
\begin{lstlisting} [caption=Test class,label={lst:vaadintestextend}]
	//test getValue() and setValue()
	@Test
	public void testSetValue() {
    private String testValue="foo";
    openWebPage();
  	Iterator it = map.entrySet().iterator();
    while (it.hasNext()) {
      Map.Entry pair = (Map.Entry)it.next();
			UIElement elem=findElementById(map.getValue());
      elem.setValue(``foo'');  
      Assert.assertEquals(elem.getValue(),testValue);        
    }
  }
\end{lstlisting}

 
\section {Challenges}
	\label {sec:challenges}
	\subsection{Look and feel testing}
	    Both C\&R and programmable tests are focused on a DOM of the Web page.
	    One disadvantage is they do not provide tools appearance of the Web page
	    like colors, margins, fonts, etc. The client side page may have bugs in CSS
	    or HTML, for example if all HTML elements had CSS rule display:none, they
	    would not be shown for a user in the Web browser. Thought all user actions
	    could be still emulated by a testing tool. This problem can be solved by adding screenshot
      comparison see \ref{sec:screencompare}, when a screenshot of a tested Web
      page is compared with a reference screenshot. 
	\subsection{Complex DOM structure}
    Real-life example may have dozens/hundreds of HTML
		elements on the Web page see example of Gmail HTML page
		\ref{fig:gmailexample}.
		Web pages with big and branched DOM bring several challenges:
		\begin{enumerate}
		  \item Searching for required element may be very resource-consuming,
		  affecting time of the test execution. 
		  \item Changes in DOM may require changes in tests, which increase
		  application maintenance costs.
		\end{enumerate}
		
		\begin{figure}
		\label{fig:gmailexample}
		\includegraphics[width=0.75\textwidth]{gmail_example}
		\caption{Gmail DOM structure example}
		\end{figure}
		
		Testing frameworks allow several strategies for locating Web page elements:
		\begin{itemize}
		  \item By id -locates the Web page elements using their id values.
		  \item By name -locates the Web page elements using their name.
		  \item By tag - locates the Web page elements using their tag.
		  \item By class - locates the Web page elements using their class attribute.
		  \item By XPath - combines previous strategies and builds a search
		  path to an element in the DOM.
		\end{itemize}
		
		The efficiency between these strategies is a trad eoff between effeciency of
		the test and its complexity for developer. The research of Maurizio Leotta
		and Diego Clerissipaper in ``An Industrial Case Study about Web Page Element
		Localization" ``shows that ID-based methods for locating Web page elements are
		better than XPath methods''\cite{selenium4} showing that tests with search by
		Xpath executed more than three times longer than same tests with searching
		elements by Id. According to the same paper ID-based test require less
		maintenance effort, than the XPath-based test suites. In fact using searching by id for static HTML Web pages with small
		amount of elements works well, but having dynamically generated HTML with 
		a lot of elements as in example \ref{fig:gmailexample} brings challenges.
		
		The biggest downside of searching by id strategy, is that every HTML element
		should have a unique ID. If the Web pages has a dynamically generated content,
		for example a table, where amount of rows depends on data, the
		developer has to add some logic to generate ID for each row and also verify
		that new ids do not conflict with already created ones. 
		
		In some circumstances the developer needs to get a set of elements by some
		criteria, for example get all elements with a specific tag or class selector
		and process them in a loop. 
		
		As we can see there is no one solution for searching elements on a Web page,
		which can be used in all cases. The developer should make a solution which
		searching algorithm to use based on requirements, but the testing framework
		should provide the developer different tools to choose from. In chapter
		\ref{ch:selenium} we will present Selenium - a software testing framework
		for Web applications, which allows to create C\&R \ref{sec:captureReplay} and 
    programmable tests \ref{sec:programTests}. Selenium  supports searching
    elements by id,tag, class, XPath, etc and provides an opportunity simulate
    user actions on a Web page.
		

 